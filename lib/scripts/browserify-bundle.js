// Generated by CoffeeScript 1.7.1
(function() {
  var ArgumentParser, browserPackWithDeps, browserify, fs, i18nExtractor, minify, parseArgs, path, relativeToCwd, writeDeps, writeI18nFile;

  fs = require('fs-extra');

  path = require('path');

  browserify = require('browserify');

  i18nExtractor = require('i18n-extractor');

  browserPackWithDeps = require('browser-pack-with-deps');

  ArgumentParser = require('argparse').ArgumentParser;

  minify = require('uglify-js').minify;

  require('coffee-script').register();

  writeI18nFile = function(file, source, done) {
    var answer, i18nExtractorOptions, key, result, warning, warnings, _i, _len;
    warnings = [];
    i18nExtractorOptions = {
      fun: new RegExp("^i18n$"),
      key: 'i18n',
      init: {},
      warnings: warnings
    };
    result = i18nExtractor(source, i18nExtractorOptions);
    for (_i = 0, _len = warnings.length; _i < _len; _i++) {
      warning = warnings[_i];
      console.log("WARNING: writing " + file + " - " + warning);
    }
    answer = {
      i18n: []
    };
    if (result.i18n) {
      for (key in result.i18n) {
        answer.i18n.push(key);
      }
    }
    return fs.writeFile(file, JSON.stringify(answer), function(err) {
      if (err) {
        return done(err);
      }
      return done();
    });
  };

  relativeToCwd = function(file, basedir) {
    if (basedir) {
      file = path.resolve(basedir, file);
    }
    return path.relative(process.cwd(), file);
  };

  writeDeps = function(sourceFile, targetFile, deps, options, done) {
    var dep, depsLine, _i, _len;
    depsLine = "" + (relativeToCwd(sourceFile, options.basedir)) + ":";
    for (_i = 0, _len = deps.length; _i < _len; _i++) {
      dep = deps[_i];
      depsLine += " " + (relativeToCwd(dep, options.basedir));
    }
    return fs.writeFile(targetFile, depsLine, done);
  };

  exports.bundle = function(target, sources, options, done) {
    var b, browserifyOptions, bundle, bundleSourceCode, deps, origPack, source, t, _i, _j, _len, _len1, _ref, _ref1;
    deps = [];
    browserifyOptions = options.browserifyOptions || {};
    if (options.deps) {
      origPack = browserifyOptions.pack;
      browserifyOptions.pack = function(params) {
        var answer;
        params.raw = true;
        params.sourceMapPrefix = '//#';
        answer = browserPackWithDeps(params, origPack);
        answer.on("dependency", function(dep) {
          return deps.push(dep);
        });
        return answer;
      };
    }
    b = browserify(browserifyOptions);
    for (_i = 0, _len = sources.length; _i < _len; _i++) {
      source = sources[_i];
      b.add(source);
    }
    _ref1 = (_ref = options.transforms) != null ? _ref : [];
    for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
      t = _ref1[_j];
      b.transform(t);
    }
    bundleSourceCode = "";
    bundle = b.bundle({
      debug: !!options.debug
    });
    bundle.on('data', function(data) {
      return bundleSourceCode += data;
    });
    bundle.on('error', done);
    return bundle.on('end', function() {
      return fs.mkdirs(path.dirname(target), function(err) {
        var doneHandler, errored, minified, pending, sourceToWrite;
        if (err) {
          return done(err);
        }
        errored = null;
        pending = 0;
        doneHandler = function(err) {
          if (errored) {
            return;
          }
          if (errored == null) {
            errored = err;
          }
          pending--;
          if (errored || pending === 0) {
            return done(errored);
          }
        };
        pending++;
        if (!options.debug) {
          minified = minify(bundleSourceCode, {
            fromString: true
          });
          sourceToWrite = minified.code;
        } else {
          sourceToWrite = bundleSourceCode;
        }
        fs.writeFile(target, sourceToWrite, doneHandler);
        if (options.deps) {
          pending++;
          writeDeps(sources[0], options.deps, deps, {
            basedir: browserifyOptions.basedir
          }, doneHandler);
        }
        if (options.i18n) {
          pending++;
          return writeI18nFile(options.i18n, bundleSourceCode, doneHandler);
        }
      });
    });
  };

  parseArgs = function() {
    var args, parser;
    parser = new ArgumentParser({
      addHelp: true,
      description: "Builds reporting.js"
    });
    parser.addArgument(['--debug'], {
      help: "Build debug files.",
      nargs: 0,
      action: 'storeTrue'
    });
    parser.addArgument(['--show'], {
      help: "Show the source generated for a file after it has been transformed."
    });
    parser.addArgument(['--out', '-o'], {
      help: "Output file.",
      nargs: "?"
    });
    parser.addArgument(['--deps', '-d'], {
      help: "Dependency output file (only works with --debug.)",
      nargs: "?"
    });
    parser.addArgument(['--i18n', '-i'], {
      help: "i18n output file.",
      nargs: "?"
    });
    parser.addArgument(['--transforms', '-t'], {
      help: "Comma delimited list of transforms to run."
    });
    parser.addArgument(['--extensions', '-e'], {
      help: "List of extensions to require automatically."
    });
    parser.addArgument(['input'], {
      help: "Files to compile.",
      nargs: "*"
    });
    args = parser.parseArgs();
    if (!args.out && !args.show) {
      parser.printUsage();
      console.log("error: --out required");
      process.exit(1);
    }
    if (!args.show && args.input.length === 0) {
      parser.printUsage();
      console.log("Must specify at least one input file.");
      process.exit(1);
    }
    return args;
  };

  (function() {
    var args, fileName, input, options, start, transform, _i, _len, _ref;
    args = parseArgs();
    options = {
      debug: args.debug,
      i18n: args.i18n,
      deps: args.deps
    };
    if (args.transforms) {
      options.transforms = args.transforms.split(',').map(function(t) {
        return require(t);
      });
    }
    if (args.extensions) {
      if (options.browserifyOptions == null) {
        options.browserifyOptions = {};
      }
      options.browserifyOptions.extensions = args.extensions.split(',');
    }
    if (args.show != null) {
      fileName = args.show;
      input = fs.createReadStream(fileName);
      _ref = options.transforms;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        transform = _ref[_i];
        input = input.pipe(transform(fileName));
      }
      return input.pipe(process.stdout);
    } else {
      start = new Date();
      return exports.bundle(args.out, args.input, options, function(err) {
        if (err) {
          console.log("Error while building " + args.out, err.stack);
          return process.exit(1);
        } else {
          return console.log("Finished building " + args.out + " in " + ((new Date() - start) / 1000) + " seconds");
        }
      });
    }
  })();

}).call(this);

//# sourceMappingURL=browserify-bundle.map
