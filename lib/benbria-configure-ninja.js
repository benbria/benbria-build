// Generated by CoffeeScript 1.7.1
(function() {
  var collectCoffeeFiles, config, edgeMapping, factories, findCommand, findLocalCommand, findScript, fp, getOptionString, getOptions, glob, globule, ld, log, makeAssetEdges, makeCommonRules, makeFingerprintEdge, makeLintEdges, makeNinja, makeSimpleRule, makeSourceEdges, makeSystemEdges, ninjaBuilder, packageJson, path, simpleMapOpt, warnMessage, _ref;

  packageJson = require('../package.json');

  ld = require('lodash');

  path = require('path');

  glob = require('glob');

  globule = require('globule');

  log = require('yadsil')('benbria-configure-ninja');

  ninjaBuilder = require('ninja-build-gen');

  factories = require('./ninjaFactories');

  _ref = require('./ninjaCommands'), findCommand = _ref.findCommand, findLocalCommand = _ref.findLocalCommand, findScript = _ref.findScript;

  log.warn = log.warning;

  config = {};

  config.ninjaFilePath = process.cwd();

  config.ninjaFile = "build.ninja";

  config.configureNinjaScript = __filename;

  config.streamlineVersion = 10;

  config.streamlineOpts = "";

  config.stylusOpts = "";

  fp = {};

  fp.assets = 'assets';

  fp.build = 'build';

  fp.buildAssets = "" + fp.build + "/" + fp.assets;

  fp.coffeelint = "" + fp.build + "/coffeelint";

  fp.fingerprintFile = "" + fp.buildAssets + "/release/fingerprints.json";

  warnMessage = "# Auto-generated by `loop-configure-ninja`.\n";

  makeSystemEdges = function(ninja, optionString, options) {
    ninja.assign('buildCoffee', findLocalCommand('coffee', config));
    ninja.assign('node', 'node');
    factories.forActiveFactory(config, log, function(factory) {
      if (factory.assignments) {
        log.debug("Generating assignments for " + factory.name);
        return factory.assignments(ninja, config);
      }
    });
    ninja.assign('uglifyjs', findLocalCommand("uglifyjs", config));
    ninja.rule('configure').run("" + (findCommand('loop-configure-ninja', config)) + optionString).description('CONFIGURE');
    return ninja.edge(config.ninjaFile).using('configure').need([findCommand('loop-configure-ninja', config)]);
  };

  makeSimpleRule = function(ninja, _arg) {
    var command, desc, display, name;
    name = _arg.name, command = _arg.command, display = _arg.display;
    desc = name.toUpperCase() + ' ' + (display != null ? display : '$in');
    return ninja.rule(name).run(command).description(desc);
  };

  makeCommonRules = function(ninja, options) {
    factories.forActiveFactory(config, log, function(factory) {
      if (factory.makeRules) {
        log.debug("Making rules for " + factory.name);
        return factory.makeRules(ninja, config);
      }
    });
    makeSimpleRule(ninja, {
      name: 'copy',
      command: 'cp $in $out'
    });
    return makeSimpleRule(ninja, {
      name: 'fingerprint',
      command: "$node " + (findScript("fingerprint.js", config)) + " $cliOptions -b $basePath -o $out $in",
      display: '$basePath'
    });
  };

  edgeMapping = function(ninja, files, mappingOptions, callback) {
    return ld.map(globule.mapping(files, mappingOptions), function(match) {
      callback(ninja.edge(match.dest).from(match.src));
      return match.dest;
    });
  };

  simpleMapOpt = function(srcBase, destBase, ext) {
    return {
      srcBase: srcBase,
      destBase: destBase,
      ext: ext,
      extDot: 'last'
    };
  };

  makeLintEdges = function(ninja, coffeeFiles) {
    var options;
    options = simpleMapOpt('.', '$builddir/coffeelint', '.coffeelint');
    return edgeMapping(ninja, coffeeFiles, options, function(edge) {
      return edge.using('coffeelint').need(['.coffeelint']);
    });
  };

  makeAssetEdges = function(ninja) {
    var assetPaths, configName, configNames, fingerprintFile, _i, _len;
    assetPaths = {};
    configNames = ['debug', 'release'];
    for (_i = 0, _len = configNames.length; _i < _len; _i++) {
      configName = configNames[_i];
      log.debug("Making " + configName + " asset edges");
      assetPaths[configName] = [];
      factories.forActiveFactory(config, log, function(factory) {
        var edges, mappingOptions, match, sourceFileNames, _j, _len1, _ref1, _results;
        if (factory.assetFiles && factory.makeAssetEdge) {
          log.debug("  " + factory.name);
          mappingOptions = simpleMapOpt(fp.assets, path.join(fp.buildAssets, configName), factory.targetExt || '.js');
          sourceFileNames = globule.find(factory.assetFiles, mappingOptions);
          _ref1 = globule.mapping(sourceFileNames, mappingOptions);
          _results = [];
          for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
            match = _ref1[_j];
            edges = factory.makeAssetEdge(ninja, match.src, match.dest, configName);
            _results.push(assetPaths[configName] = assetPaths[configName].concat(edges));
          }
          return _results;
        }
      });
    }
    ninja.edge('debug-assets').from(assetPaths.debug);
    if (assetPaths.release.length > 0) {
      log.debug("Making fingerprint edge for " + assetPaths.release.length + " release assets");
      fingerprintFile = makeFingerprintEdge(ninja, assetPaths.release);
      return ninja.edge('release-assets').from(fingerprintFile);
    } else {
      return ninja.edge('release-assets');
    }
  };

  makeSourceEdges = function(ninja) {
    var destFiles;
    destFiles = [];
    log.debug("Making src edges");
    factories.forActiveFactory(config, log, function(factory) {
      var edges, mappingOptions, match, sourceFileNames, _i, _len, _ref1, _results;
      if (factory.files && factory.makeSrcEdge) {
        log.debug("  " + factory.name);
        mappingOptions = simpleMapOpt('src', 'lib', factory.targetExt || '.js');
        sourceFileNames = globule.find(factory.files, mappingOptions);
        _ref1 = globule.mapping(sourceFileNames, mappingOptions);
        _results = [];
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          match = _ref1[_i];
          edges = factory.makeSrcEdge(ninja, match.src, match.dest);
          _results.push(destFiles = destFiles.concat(edges));
        }
        return _results;
      }
    });
    return ninja.edge('lib').from(destFiles);
  };

  makeFingerprintEdge = function(ninja, assetsEdges) {
    ninja.edge(fp.fingerprintFile).using('fingerprint').from(assetsEdges).assign('basePath', "" + fp.buildAssets + "/release");
    return fp.fingerprintFile;
  };

  collectCoffeeFiles = function(ext, options) {
    var coffeeFiles;
    log.info('looking for coffee script files..');
    coffeeFiles = [].concat(glob.sync("src/**/*." + ext), glob.sync("assets/js/**/*." + ext), glob.sync("bin/**/*." + ext), glob.sync("Gruntfile." + ext));
    log.info("found " + coffeeFiles.length + " " + ext + " scripts");
    return coffeeFiles;
  };

  makeNinja = function(options, done) {
    var files, ninja;
    ninja = ninjaBuilder('1.3', 'build');
    factories.forEachFactory(function(factory) {
      return typeof factory.initialize === "function" ? factory.initialize(ninja, config, log) : void 0;
    });
    ninja.header(warnMessage);
    if (options.ninjaColor) {
      ninja.assign('cliOptions', '--color');
    }
    makeSystemEdges(ninja, getOptionString(options), options);
    makeCommonRules(ninja, options);
    if (!options.noLint) {
      files = collectCoffeeFiles('coffee', options).concat(collectCoffeeFiles('_coffee', options));
      ninja.edge('lint').from(makeLintEdges(ninja, files));
    } else {
      ninja.edge('lint');
    }
    makeAssetEdges(ninja);
    makeSourceEdges(ninja);
    ninja.edge('debug').from(['debug-assets', 'lib']);
    ninja.edge('release').from(['release-assets', 'lib']);
    ninja.edge('all').from(['debug-assets', 'release-assets', 'lib']);
    ninja.byDefault('all');
    return done(null, ninja);
  };

  getOptionString = function(options) {
    var str;
    str = '';
    if (options.noLint) {
      str += ' --no-lint';
    }
    if (options.ninjaColor) {
      str += ' --ninja-color';
    }
    if (options.streamline8) {
      str += ' --streamline8';
    }
    if (options.streamlineOpts) {
      str += " --streamline-opts '" + options.streamlineOpts + "'";
    }
    if (options.stylusOpts) {
      str += " --stylus-opts '" + options.stylusOpts + "'";
    }
    if (options.require) {
      str += " --require '" + options.require + "'";
    }
    return str;
  };

  getOptions = function() {
    var ArgumentParser, options, parser;
    ArgumentParser = require('argparse').ArgumentParser;
    parser = new ArgumentParser({
      version: packageJson.version,
      addHelp: true,
      description: "Generates a ninja.build file for a coffeescript project."
    });
    parser.addArgument(['--require'], {
      help: "Comma delimited list of modules before building.",
      nargs: "?"
    });
    parser.addArgument(['--verbose'], {
      help: "Verbose output",
      nargs: 0
    });
    parser.addArgument(['--no-lint'], {
      help: "Disable coffee linting.",
      dest: "noLint",
      nargs: 0
    });
    parser.addArgument(['--color'], {
      help: "Force color display out of a TTY.",
      nargs: 0
    });
    parser.addArgument(['--ninja-color'], {
      help: "Force color on ninja scripts.",
      dest: "ninjaColor",
      nargs: 0
    });
    parser.addArgument(['--streamline8'], {
      help: "Use streamline 0.8.x command line arguments (instead of 0.10.x)",
      nargs: 0
    });
    parser.addArgument(['--streamline-opts'], {
      help: "Extra options for streamline compilers",
      metavar: "opts",
      dest: "streamlineOpts",
      defaultValue: ''
    });
    parser.addArgument(['--stylus-opts'], {
      help: "Extra options for stylus",
      metavar: "opts",
      dest: "stylusOpts",
      defaultValue: ''
    });
    options = parser.parseArgs(process.argv.slice(2));
    if (options.ninjaColor) {
      options.color = true;
    }
    log.verbose(options.verbose);
    if (options.color) {
      log.color(options.color);
    }
    if (log.color()) {
      options.ninjaColor = true;
    }
    return options;
  };

  module.exports = function(configureNinjaScript) {
    var mod, options, _i, _len, _ref1;
    config.configureNinjaScript = configureNinjaScript;
    options = getOptions();
    if (options.streamline8) {
      config.streamlineVersion = 8;
    }
    config.streamlineOpts = options.streamlineOpts;
    config.stylusOpts = options.stylusOpts;
    if (options.require) {
      _ref1 = options.require.split(',');
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        mod = _ref1[_i];
        if (mod.indexOf('./') === 0) {
          mod = path.resolve(mod);
        }
        require(mod);
      }
    }
    return makeNinja(options, function(err, ninja) {
      var ninjaFile;
      if (err) {
        throw err;
      }
      ninjaFile = path.resolve(config.ninjaFilePath, config.ninjaFile);
      ninja.save(ninjaFile);
      return log.info("generated \'" + ninjaFile + "\' (" + ninja.ruleCount + " rules, " + ninja.edgeCount + " edges)");
    });
  };

}).call(this);

//# sourceMappingURL=benbria-configure-ninja.map
